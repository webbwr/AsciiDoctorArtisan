# v2.0.0 Syntax Checking Implementation Plan

**Feature:** Real-Time Syntax Error Detection with Quick Fixes
**Estimated Effort:** 16-24 hours
**Status:** ðŸ“‹ PLANNING â†’ ðŸš§ IMPLEMENTATION
**Created:** November 8, 2025

---

## Table of Contents

1. [Overview](#overview)
2. [Requirements](#requirements)
3. [Error Catalog](#error-catalog)
4. [Architecture](#architecture)
5. [Implementation Phases](#implementation-phases)
6. [API Design](#api-design)
7. [Test Strategy](#test-strategy)
8. [Performance Optimization](#performance-optimization)
9. [User Experience](#user-experience)

---

## Overview

### Goals

Build a real-time syntax checker that:
- Detects 50+ AsciiDoc syntax errors
- Shows visual indicators (underlines, gutter icons)
- Provides quick fixes with lightbulb UI
- Responds in <100ms for 1000-line documents

### User Benefits

- **Catch errors early** before preview/export
- **Learn AsciiDoc** from error messages
- **Fix errors quickly** with one-click fixes
- **Maintain quality** with style suggestions

---

## Requirements

### Functional Requirements

1. **Error Detection**
   - Syntax errors: Missing closing brackets, invalid attributes
   - Semantic errors: Broken cross-references, missing includes
   - Style warnings: Inconsistent formatting, deprecated syntax
   - Best practice suggestions: TOC placement, heading structure

2. **Visual Indicators**
   - Red underlines for errors (E001-E050)
   - Yellow underlines for warnings (W001-W050)
   - Blue underlines for info/style (I001-I050)
   - Gutter icons: ðŸ”´ ðŸŸ¡ ðŸ”µ

3. **Quick Fixes**
   - Lightbulb icon (ðŸ’¡) on hover over error
   - List of suggested fixes
   - Apply fix with Enter or click
   - Multiple fixes per error (when applicable)

4. **Error Panel** (Optional Phase 4)
   - List all errors in document
   - Jump to error on click
   - Filter by severity

### Non-Functional Requirements

1. **Performance**
   - <100ms validation for 1000-line document
   - <500ms debounce after typing stops
   - Incremental validation (only changed lines)

2. **UX**
   - Real-time updates without UI blocking
   - Hover shows error message
   - F8 keyboard shortcut to jump to next error
   - Configurable severity levels

3. **Extensibility**
   - Easy to add new error rules
   - Plugin API for custom validators (v3.0+)

---

## Error Catalog

### Syntax Errors (E001-E050)

**Critical errors that break document:**

| Code | Error | Example | Quick Fix |
|------|-------|---------|-----------|
| E001 | Unclosed block delimiter | `[source]` without `----` | Add closing delimiter |
| E002 | Invalid attribute syntax | `:author John` (missing `:`) | Add closing `:` |
| E003 | Malformed cross-reference | `<<target` (missing `>>`) | Add closing `>>` |
| E004 | Invalid list item | `**` (wrong marker) | Change to `*` |
| E005 | Unclosed inline formatting | `*bold text` (missing `*`) | Add closing `*` |
| E006 | Invalid heading level | `======` (6 levels, max 5) | Change to `=====` |
| E007 | Malformed include | `include:path[]` (missing `::`) | Change to `include::` |
| E008 | Invalid table delimiter | `|====` (wrong char) | Change to `|===` |
| E009 | Unclosed attribute list | `[source,python` (missing `]`) | Add closing `]` |
| E010 | Invalid anchor syntax | `[[anchor` (missing `]]`) | Add closing `]]` |

**Additional syntax errors (E011-E050):**
- Malformed links, images, admonitions
- Invalid block types
- Broken passthrough syntax
- Invalid table cells
- Malformed footnotes
- Invalid preprocessor directives

### Semantic Errors (W001-W025)

**Errors that don't break syntax but affect output:**

| Code | Warning | Example | Quick Fix |
|------|---------|---------|-----------|
| W001 | Broken cross-reference | `<<nonexistent>>` | Show available targets |
| W002 | Missing include file | `include::missing.adoc[]` | Create file or remove |
| W003 | Undefined attribute | `{undefined-attr}` | Define attribute |
| W004 | Duplicate anchor ID | `[[id]]` used twice | Rename second anchor |
| W005 | Empty heading | `== ` (no text) | Add heading text |
| W006 | Invalid URL | `link:htp://example` (typo) | Fix URL scheme |
| W007 | Inconsistent list markers | `*` then `-` | Make consistent |
| W008 | Table column mismatch | 3 cells, 2 columns | Add/remove cells |
| W009 | Invalid language code | `[source,pyton]` (typo) | Fix to `python` |
| W010 | Broken image path | Image file not found | Fix path |

### Style Warnings (W026-W050)

**Non-critical style issues:**

| Code | Warning | Suggestion |
|------|---------|------------|
| W026 | Deprecated syntax | Old link syntax â†’ New syntax |
| W027 | Inconsistent attribute case | `:Author:` â†’ `:author:` |
| W028 | Missing blank line | After heading, before block |
| W029 | Trailing whitespace | Remove trailing spaces |
| W030 | Inconsistent heading hierarchy | Skip heading levels |

### Info/Best Practices (I001-I050)

**Suggestions for better documents:**

| Code | Info | Suggestion |
|------|------|------------|
| I001 | TOC not at top | Move `:toc:` to header |
| I002 | Missing document title | Add `= Title` |
| I003 | No author/version | Add `:author:`, `:version:` |
| I004 | Deep heading nesting | Max 3-4 levels recommended |
| I005 | Long paragraph | Consider splitting (>300 words) |
| I006 | Missing alt text | Add alt text to images |
| I007 | Generic link text | "click here" â†’ descriptive text |
| I008 | Bare URL | Use link macro for better rendering |
| I009 | Inconsistent terminology | Use consistent terms |
| I010 | Missing code language | Add language to source blocks |

---

## Architecture

### Components

```
core/
â”œâ”€â”€ syntax_checker.py          # Core validation engine
â”œâ”€â”€ syntax_validators.py       # Validation rule implementations
â”œâ”€â”€ syntax_rules.py            # Error catalog and rule definitions
â”œâ”€â”€ quick_fix_provider.py      # Quick fix suggestions
â””â”€â”€ models.py                  # SyntaxError, QuickFix, ErrorSeverity

ui/
â”œâ”€â”€ syntax_checker_manager.py  # UI integration and underlines
â”œâ”€â”€ syntax_error_panel.py      # Error list panel (optional Phase 4)
â””â”€â”€ quick_fix_widget.py        # Lightbulb popup (Phase 4)
```

### Data Flow

```
User types â†’ Editor TextChanged (debounced 500ms)
    â†“
SyntaxCheckerManager.on_text_changed()
    â†“
Extract changed lines (incremental validation)
    â†“
SyntaxChecker.validate(document)
    â†“
Apply all validators (Syntax, Semantic, Style)
    â†“
Collect errors with line/column positions
    â†“
QuickFixProvider.get_fixes(error)
    â†“
SyntaxCheckerManager.show_errors(errors)
    â†“
Add underlines and gutter icons to editor
```

### Thread Safety

- **Checker:** Runs in background QThread (non-blocking UI)
- **Validators:** Stateless, thread-safe
- **Manager:** Main thread only (Qt requirement)
- **Communication:** Signals/slots (errors_ready signal)

---

## Implementation Phases

### Phase 1: Core Checker (6-8h)

**Goal:** Build validation engine with basic error detection

**Files:**
- `core/syntax_checker.py`
- `core/syntax_rules.py`
- `core/models.py` (SyntaxError, ErrorSeverity, QuickFix)

**Features:**
- Rule-based validation engine
- 20 syntax error rules (E001-E020)
- Line/column position tracking
- Incremental validation (only changed lines)

**Tests:** 30 unit tests
- Basic errors: unclosed blocks, invalid attributes
- Position tracking: correct line/column
- Incremental: only validate changed lines
- Edge cases: empty document, very long lines

### Phase 2: Validators (4-6h)

**Goal:** Add semantic and style validators

**Files:**
- `core/syntax_validators.py`

**Validators:**
1. **SemanticValidator** - Cross-references, includes, attributes
2. **StyleValidator** - Formatting, deprecated syntax
3. **BestPracticeValidator** - Document structure suggestions

**Features:**
- 30 more error rules (E021-E050, W001-W030, I001-I020)
- Context-aware validation (cross-references need anchor list)
- Custom validators can be added

**Tests:** 20 unit tests
- Semantic: broken xrefs, missing includes
- Style: deprecated syntax, inconsistent formatting
- Best practice: TOC placement, heading hierarchy

### Phase 3: Qt Integration (4-6h)

**Goal:** Visual indicators and editor integration

**Files:**
- `ui/syntax_checker_manager.py`

**Features:**
- Underlines: QTextEdit.ExtraSelection for colored underlines
- Gutter icons: Line numbers with icon overlay
- Hover tooltip: Show error message on hover
- F8 shortcut: Jump to next error
- Debounced validation (500ms after typing stops)

**Tests:** 15 Qt tests
- Underlines: correct color, position, length
- Gutter icons: correct icon, position
- Hover: tooltip shows error message
- F8: jumps to next error
- Debounce: validation delayed 500ms

### Phase 4: Quick Fixes (2-4h)

**Goal:** One-click error fixes

**Files:**
- `core/quick_fix_provider.py`
- `ui/quick_fix_widget.py`

**Features:**
- Quick fix suggestions for common errors
- Lightbulb icon on hover
- Apply fix with Enter or click
- Multiple fixes per error (when applicable)

**Built-in Fixes:**
- Add closing delimiters
- Fix typos in keywords
- Add missing syntax elements
- Format corrections

**Tests:** 30 unit tests
- Fix generation: correct edits for each error type
- Fix application: text correctly modified
- Multiple fixes: all variants offered
- Edge cases: fix at start/end of document

---

## API Design

### SyntaxError

```python
from dataclasses import dataclass
from enum import Enum
from typing import List, Optional

class ErrorSeverity(Enum):
    """Error severity level"""
    ERROR = "error"      # Red - breaks document
    WARNING = "warning"  # Yellow - semantic issues
    INFO = "info"        # Blue - style/best practice

@dataclass
class TextEdit:
    """Single text edit operation"""
    start_line: int      # Start line (0-indexed)
    start_column: int    # Start column (0-indexed)
    end_line: int        # End line (0-indexed)
    end_column: int      # End column (0-indexed)
    new_text: str        # Replacement text

@dataclass
class QuickFix:
    """Quick fix suggestion"""
    title: str           # Fix description ("Add closing delimiter")
    edits: List[TextEdit]  # List of edits to apply

@dataclass
class SyntaxError:
    """Syntax error with position and fixes"""
    code: str                          # E001, W001, I001
    severity: ErrorSeverity            # ERROR, WARNING, INFO
    message: str                       # Human-readable message
    line: int                          # Line number (0-indexed)
    column: int                        # Column number (0-indexed)
    length: int                        # Error span length
    fixes: List[QuickFix] = None       # Suggested quick fixes

    def __post_init__(self) -> None:
        """Set defaults"""
        if self.fixes is None:
            self.fixes = []
```

### ValidationRule

```python
from abc import ABC, abstractmethod
from typing import List, Protocol

class ValidationContext:
    """Context for validation"""
    def __init__(self, document: str, changed_lines: Optional[List[int]] = None) -> None:
        self.document = document
        self.lines = document.splitlines()
        self.changed_lines = changed_lines  # None = validate all

        # Caches (populated on demand)
        self._anchors: Optional[List[str]] = None
        self._attributes: Optional[Dict[str, str]] = None

    @property
    def anchors(self) -> List[str]:
        """Extract all anchors from document"""
        if self._anchors is None:
            import re
            self._anchors = re.findall(r'\[\[([^\]]+)\]\]', self.document)
        return self._anchors

    @property
    def attributes(self) -> Dict[str, str]:
        """Extract all attributes from document"""
        if self._attributes is None:
            import re
            matches = re.findall(r'^:([^:]+):\s*(.*)$', self.document, re.MULTILINE)
            self._attributes = {key: value for key, value in matches}
        return self._attributes

class ValidationRule(ABC):
    """Base class for validation rules"""

    @abstractmethod
    def validate(self, context: ValidationContext) -> List[SyntaxError]:
        """Validate document and return errors"""
        pass
```

### SyntaxChecker

```python
class SyntaxChecker:
    """Core syntax checking engine"""

    def __init__(self) -> None:
        self.rules: List[ValidationRule] = []
        self._setup_rules()

    def _setup_rules(self) -> None:
        """Initialize validation rules"""
        from .syntax_validators import (
            UnclosedBlockRule,
            InvalidAttributeRule,
            MalformedXRefRule,
            BrokenXRefRule,
            MissingIncludeRule,
            DeprecatedSyntaxRule,
        )

        # Syntax rules (E001-E050)
        self.rules.append(UnclosedBlockRule())
        self.rules.append(InvalidAttributeRule())
        self.rules.append(MalformedXRefRule())

        # Semantic rules (W001-W025)
        self.rules.append(BrokenXRefRule())
        self.rules.append(MissingIncludeRule())

        # Style rules (W026-W050)
        self.rules.append(DeprecatedSyntaxRule())

    def validate(
        self,
        document: str,
        changed_lines: Optional[List[int]] = None
    ) -> List[SyntaxError]:
        """
        Validate document and return errors.

        Args:
            document: Full document text
            changed_lines: Lines that changed (None = validate all)

        Returns:
            List of syntax errors
        """
        context = ValidationContext(document, changed_lines)
        errors: List[SyntaxError] = []

        for rule in self.rules:
            try:
                rule_errors = rule.validate(context)
                errors.extend(rule_errors)
            except Exception as e:
                # Log rule failure, don't crash checker
                import logging
                logging.error(f"Rule {rule.__class__.__name__} failed: {e}")

        # Sort by line, then column
        errors.sort(key=lambda e: (e.line, e.column))

        return errors

    def add_rule(self, rule: ValidationRule) -> None:
        """Add custom validation rule"""
        self.rules.append(rule)
```

### Example Validation Rules

**UnclosedBlockRule:**

```python
import re

class UnclosedBlockRule(ValidationRule):
    """Detect unclosed block delimiters"""

    BLOCK_PATTERNS = {
        'source': (r'\[source[^\]]*\]', r'^----$'),
        'example': (r'\[example\]', r'^====+$'),
        'sidebar': (r'\[sidebar\]', r'^\*\*\*\*+$'),
        'quote': (r'\[quote[^\]]*\]', r'^____+$'),
    }

    def validate(self, context: ValidationContext) -> List[SyntaxError]:
        errors = []
        lines = context.lines

        for block_type, (start_pattern, end_pattern) in self.BLOCK_PATTERNS.items():
            # Find all block starts
            for i, line in enumerate(lines):
                if re.search(start_pattern, line):
                    # Look for closing delimiter
                    found_close = False
                    for j in range(i + 1, len(lines)):
                        if re.match(end_pattern, lines[j]):
                            found_close = True
                            break

                    if not found_close:
                        errors.append(SyntaxError(
                            code="E001",
                            severity=ErrorSeverity.ERROR,
                            message=f"Unclosed {block_type} block (missing closing delimiter)",
                            line=i,
                            column=0,
                            length=len(line),
                            fixes=[QuickFix(
                                title="Add closing delimiter",
                                edits=[TextEdit(
                                    start_line=i + 1,
                                    start_column=0,
                                    end_line=i + 1,
                                    end_column=0,
                                    new_text="----\n" if block_type == 'source' else "====\n"
                                )]
                            )]
                        ))

        return errors
```

**BrokenXRefRule:**

```python
class BrokenXRefRule(ValidationRule):
    """Detect broken cross-references"""

    def validate(self, context: ValidationContext) -> List[SyntaxError]:
        errors = []
        lines = context.lines
        anchors = set(context.anchors)

        # Find all cross-references
        xref_pattern = r'<<([^>]+)>>'
        for i, line in enumerate(lines):
            for match in re.finditer(xref_pattern, line):
                target = match.group(1).split(',')[0].strip()

                if target not in anchors:
                    # Suggest similar anchors (fuzzy match)
                    from rapidfuzz import process
                    suggestions = process.extract(target, list(anchors), limit=3)

                    fixes = [
                        QuickFix(
                            title=f"Change to '{suggestion[0]}'",
                            edits=[TextEdit(
                                start_line=i,
                                start_column=match.start(),
                                end_line=i,
                                end_column=match.end(),
                                new_text=f"<<{suggestion[0]}>>"
                            )]
                        )
                        for suggestion in suggestions if suggestion[1] > 60
                    ]

                    errors.append(SyntaxError(
                        code="W001",
                        severity=ErrorSeverity.WARNING,
                        message=f"Broken cross-reference: '{target}' not found",
                        line=i,
                        column=match.start(),
                        length=match.end() - match.start(),
                        fixes=fixes
                    ))

        return errors
```

### SyntaxCheckerManager

```python
from PySide6.QtWidgets import QPlainTextEdit
from PySide6.QtGui import QTextEdit, QColor
from PySide6.QtCore import QObject, QTimer, Signal

class SyntaxCheckerManager(QObject):
    """Manages syntax checking for editor"""

    errors_changed = Signal(list)  # Emitted when errors change

    def __init__(self, editor: QPlainTextEdit, checker: SyntaxChecker) -> None:
        super().__init__()
        self.editor = editor
        self.checker = checker
        self.errors: List[SyntaxError] = []

        # Debounce timer
        self.timer = QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self._validate)

        # Settings
        self.enabled = True
        self.debounce_delay = 500  # ms

        # Connect editor
        self.editor.textChanged.connect(self._on_text_changed)

    def _on_text_changed(self) -> None:
        """Handle text change"""
        if not self.enabled:
            return

        # Restart debounce timer
        self.timer.stop()
        self.timer.start(self.debounce_delay)

    def _validate(self) -> None:
        """Run validation"""
        document = self.editor.toPlainText()
        self.errors = self.checker.validate(document)

        # Update UI
        self._show_errors()
        self.errors_changed.emit(self.errors)

    def _show_errors(self) -> None:
        """Show error underlines"""
        # Clear previous underlines
        self.editor.setExtraSelections([])

        # Create selections for each error
        selections = []
        for error in self.errors:
            selection = QTextEdit.ExtraSelection()

            # Set underline color by severity
            if error.severity == ErrorSeverity.ERROR:
                color = QColor(255, 0, 0)  # Red
            elif error.severity == ErrorSeverity.WARNING:
                color = QColor(255, 165, 0)  # Orange/Yellow
            else:
                color = QColor(0, 0, 255)  # Blue

            # Set format
            selection.format.setUnderlineColor(color)
            selection.format.setUnderlineStyle(QTextCharFormat.WaveUnderline)

            # Set cursor position
            cursor = self.editor.textCursor()
            cursor.movePosition(QTextCursor.Start)
            for _ in range(error.line):
                cursor.movePosition(QTextCursor.Down)
            cursor.movePosition(QTextCursor.Right, QTextCursor.MoveAnchor, error.column)
            cursor.movePosition(QTextCursor.Right, QTextCursor.KeepAnchor, error.length)

            selection.cursor = cursor
            selections.append(selection)

        # Apply selections
        self.editor.setExtraSelections(selections)

    def jump_to_next_error(self) -> None:
        """Jump to next error (F8)"""
        if not self.errors:
            return

        cursor = self.editor.textCursor()
        current_line = cursor.blockNumber()

        # Find next error after current position
        for error in self.errors:
            if error.line > current_line:
                self._jump_to_error(error)
                return

        # Wrap around to first error
        if self.errors:
            self._jump_to_error(self.errors[0])

    def _jump_to_error(self, error: SyntaxError) -> None:
        """Jump cursor to error"""
        cursor = self.editor.textCursor()
        cursor.movePosition(QTextCursor.Start)
        for _ in range(error.line):
            cursor.movePosition(QTextCursor.Down)
        cursor.movePosition(QTextCursor.Right, QTextCursor.MoveAnchor, error.column)
        self.editor.setTextCursor(cursor)
        self.editor.ensureCursorVisible()
```

---

## Test Strategy

### Unit Tests (80 tests)

**SyntaxChecker (20 tests):**
- `test_validate_empty_document()`
- `test_validate_no_errors()`
- `test_validate_single_error()`
- `test_validate_multiple_errors()`
- `test_incremental_validation()`
- `test_error_sorting()`
- `test_rule_exception_handling()`
- `test_add_custom_rule()`
- `test_performance_1000_lines()` - <100ms
- `test_performance_10000_lines()` - <1s

**Validation Rules (50 tests):**
- Each rule: positive (error found), negative (no error), edge cases
- E001-E010: 20 tests (2 per rule)
- W001-W010: 20 tests (2 per rule)
- I001-I005: 10 tests (2 per rule)

**QuickFixProvider (10 tests):**
- `test_fix_unclosed_block()`
- `test_fix_invalid_attribute()`
- `test_fix_malformed_xref()`
- `test_fix_broken_xref()`
- `test_multiple_fixes_offered()`
- `test_apply_fix()`
- `test_fix_at_document_start()`
- `test_fix_at_document_end()`
- `test_fix_multiline()`
- `test_no_fixes_available()`

### Integration Tests (15 tests)

**Qt Manager Tests:**
- `test_manager_debounce()`
- `test_manager_underlines_shown()`
- `test_manager_underline_colors()`
- `test_manager_hover_tooltip()`
- `test_manager_jump_to_error()`
- `test_manager_jump_wraps_around()`
- `test_manager_enabled_disabled()`
- `test_manager_errors_changed_signal()`

**End-to-End Tests:**
- `test_e2e_type_creates_error()`
- `test_e2e_fix_error_removes_underline()`
- `test_e2e_f8_jumps_to_error()`
- `test_e2e_multiple_errors()`
- `test_e2e_incremental_update()`
- `test_e2e_quick_fix_applied()`
- `test_e2e_performance()` - realistic document

**Total: 95 tests**

---

## Performance Optimization

### Strategies

1. **Incremental Validation**
   - Only validate changed lines (not entire document)
   - Track which lines changed via QTextDocument.contentsChange
   - 10-20x faster for typical edits

2. **Debouncing**
   - 500ms delay after typing stops
   - Cancel previous validation if new text arrives
   - Prevents validation on every keystroke

3. **Rule Optimization**
   - Cache expensive operations (regex compilation, anchor extraction)
   - Early exit for rules that don't apply
   - Limit regex backtracking with timeouts

4. **Threading**
   - Run validation in background QThread
   - Non-blocking UI updates via signals
   - Progress indicator for very large documents

5. **Smart Caching**
   - Cache ValidationContext (anchors, attributes)
   - Reuse context for multiple rules
   - Clear cache on document change

### Benchmarks

**Target Performance:**
- 100-line document: <20ms
- 1000-line document: <100ms
- 10000-line document: <1s
- Incremental (1 line changed): <10ms

---

## User Experience

### Visual Indicators

**Underlines:**
- Red wavy for errors
- Yellow wavy for warnings
- Blue wavy for info

**Gutter Icons:**
- ðŸ”´ Red circle for errors
- ðŸŸ¡ Yellow triangle for warnings
- ðŸ”µ Blue circle for info

**Hover Tooltip:**
- Show error message
- Show error code (E001, W001, I001)
- Show quick fix count (if available)

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `F8` | Jump to next error |
| `Shift+F8` | Jump to previous error |
| `Ctrl+.` | Show quick fixes (when on error) |
| `Alt+Enter` | Apply first quick fix |

### Settings

```python
# In core/settings.py

syntax_check_enabled: bool = True
syntax_check_debounce: int = 500  # ms
syntax_check_show_errors: bool = True
syntax_check_show_warnings: bool = True
syntax_check_show_info: bool = False  # Info disabled by default
syntax_check_gutter_icons: bool = True
```

---

## Next Steps

1. âœ… Create detailed plan
2. ðŸ“‹ Implement Phase 1: Core Checker (6-8h)
3. ðŸ“‹ Implement Phase 2: Validators (4-6h)
4. ðŸ“‹ Implement Phase 3: Qt Integration (4-6h)
5. ðŸ“‹ Implement Phase 4: Quick Fixes (2-4h)
6. ðŸ“‹ Write documentation
7. ðŸ“‹ Integration testing

---

**Last Updated:** November 8, 2025
**Owner:** AsciiDoc Artisan Development Team
**Status:** Ready for Implementation
