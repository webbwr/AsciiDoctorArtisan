# v2.0.0 Auto-Complete Implementation Plan

**Feature:** Intelligent Auto-Complete System
**Estimated Effort:** 24-32 hours
**Status:** ðŸ“‹ PLANNING â†’ ðŸš§ IMPLEMENTATION
**Created:** November 8, 2025

---

## Table of Contents

1. [Overview](#overview)
2. [Requirements](#requirements)
3. [Architecture](#architecture)
4. [Implementation Phases](#implementation-phases)
5. [API Design](#api-design)
6. [Test Strategy](#test-strategy)
7. [Performance Optimization](#performance-optimization)
8. [User Experience](#user-experience)

---

## Overview

### Goals

Build a VSCode-style auto-complete system that:
- Completes AsciiDoc syntax (headings, lists, blocks)
- Suggests attributes, cross-references, include paths
- Expands snippets for common patterns
- Responds in <50ms with fuzzy matching

### User Benefits

- **40% faster** document creation
- **Reduced errors** from correct syntax suggestions
- **Easier learning** for AsciiDoc beginners
- **Power user features** like snippets

---

## Requirements

### Functional Requirements

1. **Syntax Completion**
   - Headings: `=` â†’ `= Heading`, `==` â†’ `== Subheading`
   - Lists: `*` â†’ `* Item`, `-` â†’ `- Item`, `.` â†’ `. Item`
   - Blocks: `[source` â†’ `[source,python]`, `[example]` â†’ full example block
   - Inline: `link:` â†’ `link:URL[text]`, `image:` â†’ `image::path[]`

2. **Attribute Completion**
   - Built-in attributes: `:author:`, `:version:`, `:toc:`, `:icons:`
   - Custom attributes from document (`:my-attr:`)
   - Attribute references: `{author}`, `{version}`

3. **Cross-Reference Completion**
   - Detect all anchors: `[[anchor-id]]`, `[#anchor-id]`
   - Suggest in `<<>>` syntax: `<<an` â†’ `<<anchor-id>>`
   - Fuzzy matching on anchor text

4. **Include Path Completion**
   - File system search: `include::` â†’ show `.adoc` files
   - Relative paths from current document
   - Recently used files first

5. **Snippet Expansion**
   - `tab` â†’ table template
   - `fig` â†’ figure with caption
   - `code` â†’ source block with language
   - `adm` â†’ admonition (NOTE, TIP, WARNING, etc.)

### Non-Functional Requirements

1. **Performance**
   - <50ms response time for completion
   - <25ms for snippet expansion
   - Support 1000+ completion items

2. **UX**
   - Show completions automatically (300ms delay)
   - Manual trigger: Ctrl+Space
   - Keyboard navigation: Up/Down, Enter, Escape
   - Documentation preview pane (optional)

3. **Configurability**
   - Enable/disable auto-complete
   - Auto-trigger delay (default: 300ms)
   - Maximum items shown (default: 100)
   - Custom snippet library

---

## Architecture

### Components

```
core/
â”œâ”€â”€ autocomplete_engine.py      # Core matching and ranking logic
â”œâ”€â”€ autocomplete_providers.py   # Content providers (Syntax, Attr, XRef, Include, Snippet)
â””â”€â”€ models.py                   # CompletionItem, CompletionKind, CompletionContext

ui/
â”œâ”€â”€ autocomplete_widget.py      # Qt popup list widget
â””â”€â”€ autocomplete_manager.py     # Coordinator between editor and engine
```

### Data Flow

```
User types â†’ Editor TextChanged
    â†“
AutoCompleteManager.on_text_changed()
    â†“
Extract context (current line, cursor position, previous text)
    â†“
AutoCompleteEngine.get_completions(context)
    â†“
Query all providers (Syntax, Attribute, XRef, Include, Snippet)
    â†“
Rank and filter results (fuzzy matching, score sorting)
    â†“
AutoCompleteWidget.show_completions(items)
    â†“
User selects item â†’ Insert text
```

### Thread Safety

- **Engine:** Runs in background QThread (non-blocking UI)
- **Providers:** Thread-safe, no shared state
- **Widget:** Main thread only (Qt requirement)
- **Communication:** Signals/slots (completion_ready signal)

---

## Implementation Phases

### Phase 1: Core Engine (8-10h)

**Goal:** Build matching and ranking logic

**Files:**
- `core/autocomplete_engine.py`
- `core/models.py` (CompletionItem, CompletionKind, CompletionContext)

**Features:**
- Fuzzy matching with rapidfuzz
- Ranking algorithm (prefix match > fuzzy match > alphabetical)
- Filtering by prefix/substring
- Caching (LRU cache for 1000 items)

**Tests:** 40 unit tests
- Matching: exact, prefix, fuzzy, no match
- Ranking: prefix > fuzzy, score sorting
- Filtering: max items, minimum score threshold
- Caching: cache hit/miss, eviction

### Phase 2: Providers (6-8h)

**Goal:** Build content providers for each completion type

**Files:**
- `core/autocomplete_providers.py`

**Providers:**
1. **SyntaxProvider** - AsciiDoc syntax elements
2. **AttributeProvider** - Attributes and attribute references
3. **CrossRefProvider** - Cross-references to anchors
4. **IncludeProvider** - Include file paths
5. **SnippetProvider** - Expandable snippets

**Tests:** 15 unit tests
- Each provider: completions, ranking, edge cases
- Integration: multiple providers combined

### Phase 3: Qt Integration (6-8h)

**Goal:** Build popup widget and editor integration

**Files:**
- `ui/autocomplete_widget.py`
- `ui/autocomplete_manager.py`

**Features:**
- Popup list widget (QListWidget-based)
- Keyboard navigation (Up/Down, Enter, Escape)
- Auto-show on typing (300ms debounce)
- Manual trigger (Ctrl+Space)
- Insert completion on Enter
- Documentation preview (optional Phase 4 feature)

**Tests:** 10 Qt tests
- Widget: show/hide, keyboard navigation, selection
- Manager: trigger on typing, manual trigger, insert text

### Phase 4: Snippets (4-6h)

**Goal:** Build snippet expansion system

**Files:**
- `core/snippet_library.py`
- `templates/snippets/` (snippet files)

**Features:**
- Snippet format: JSON with placeholders
- Tab stop navigation ($1, $2, $3)
- Default values (${1:default})
- Multi-line snippets
- Custom snippet directory

**Built-in Snippets:**
- `tab` - Table
- `fig` - Figure with caption
- `code` - Source block
- `adm` - Admonition
- `list` - Nested list
- `sect` - Section with subsections

**Tests:** 20 unit tests
- Loading: built-in, custom, error handling
- Expansion: placeholders, tab stops, defaults
- Navigation: next/previous tab stop

---

## API Design

### CompletionItem

```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional

class CompletionKind(Enum):
    """Type of completion item"""
    SYNTAX = "syntax"          # AsciiDoc syntax elements
    ATTRIBUTE = "attribute"    # Document attributes
    XREF = "xref"             # Cross-references
    INCLUDE = "include"        # Include paths
    SNIPPET = "snippet"        # Expandable snippets

@dataclass
class CompletionItem:
    """Single completion item"""
    text: str                          # Display text
    kind: CompletionKind               # Completion type
    detail: str                        # Short description
    documentation: str = ""            # Full documentation (markdown)
    insert_text: Optional[str] = None  # Text to insert (defaults to text)
    sort_text: Optional[str] = None    # Custom sort key
    filter_text: Optional[str] = None  # Custom filter key
    score: float = 0.0                 # Ranking score (0-100)

    def __post_init__(self) -> None:
        """Set defaults after initialization"""
        if self.insert_text is None:
            self.insert_text = self.text
        if self.sort_text is None:
            self.sort_text = self.text
        if self.filter_text is None:
            self.filter_text = self.text
```

### CompletionContext

```python
@dataclass
class CompletionContext:
    """Context for completion request"""
    line: str                    # Current line text
    line_number: int             # Line number (0-indexed)
    column: int                  # Cursor column (0-indexed)
    prefix: str                  # Text before cursor on current line
    trigger_char: Optional[str]  # Character that triggered completion (:, [, etc.)
    manual: bool = False         # True if manually triggered (Ctrl+Space)

    @property
    def word_before_cursor(self) -> str:
        """Extract word before cursor"""
        words = self.prefix.split()
        return words[-1] if words else ""
```

### AutoCompleteEngine

```python
from typing import List, Protocol

class CompletionProvider(Protocol):
    """Interface for completion providers"""
    def get_completions(self, context: CompletionContext) -> List[CompletionItem]:
        """Return completions for given context"""
        ...

class AutoCompleteEngine:
    """Core auto-complete engine"""

    def __init__(self) -> None:
        self.providers: List[CompletionProvider] = []
        self._cache: dict = {}  # LRU cache

    def add_provider(self, provider: CompletionProvider) -> None:
        """Register a completion provider"""
        self.providers.append(provider)

    def get_completions(
        self,
        context: CompletionContext,
        max_items: int = 100
    ) -> List[CompletionItem]:
        """
        Get completions for given context.

        Args:
            context: Completion context
            max_items: Maximum items to return

        Returns:
            Ranked list of completion items
        """
        # Check cache
        cache_key = self._get_cache_key(context)
        if cache_key in self._cache:
            return self._cache[cache_key]

        # Query all providers
        items: List[CompletionItem] = []
        for provider in self.providers:
            items.extend(provider.get_completions(context))

        # Rank and filter
        ranked = self._rank_items(items, context)
        filtered = ranked[:max_items]

        # Cache result
        self._cache[cache_key] = filtered

        return filtered

    def _rank_items(
        self,
        items: List[CompletionItem],
        context: CompletionContext
    ) -> List[CompletionItem]:
        """
        Rank items by relevance.

        Scoring:
        - Exact prefix match: 100
        - Prefix match: 80 + (1 - pos/len) * 10
        - Fuzzy match: fuzzy_score * 0.6
        - No match: 0
        """
        from rapidfuzz import fuzz

        query = context.word_before_cursor.lower()
        scored_items: List[CompletionItem] = []

        for item in items:
            text = item.filter_text.lower()

            # Exact match
            if text == query:
                item.score = 100.0
            # Prefix match
            elif text.startswith(query):
                pos = 0
                item.score = 80.0 + (1 - pos / len(text)) * 10
            # Fuzzy match
            else:
                fuzzy_score = fuzz.ratio(query, text)
                item.score = fuzzy_score * 0.6

            if item.score > 0:
                scored_items.append(item)

        # Sort by score (descending), then alphabetically
        scored_items.sort(key=lambda x: (-x.score, x.sort_text))

        return scored_items

    def _get_cache_key(self, context: CompletionContext) -> str:
        """Generate cache key from context"""
        return f"{context.line_number}:{context.column}:{context.word_before_cursor}"
```

### SyntaxProvider

```python
class SyntaxProvider:
    """Provides AsciiDoc syntax completions"""

    def __init__(self) -> None:
        self.completions = self._build_completion_items()

    def get_completions(self, context: CompletionContext) -> List[CompletionItem]:
        """Return syntax completions"""
        # Filter based on context
        prefix = context.word_before_cursor

        # Special handling for headings
        if context.line.strip().startswith("="):
            return self._get_heading_completions(context)

        # Special handling for blocks
        if context.prefix.strip().endswith("["):
            return self._get_block_completions(context)

        # Default: return all syntax items
        return self.completions

    def _build_completion_items(self) -> List[CompletionItem]:
        """Build static list of syntax completions"""
        return [
            # Headings
            CompletionItem(
                text="= Heading",
                kind=CompletionKind.SYNTAX,
                detail="Level 1 heading (document title)",
                documentation="# Level 1 Heading\n\nUsed for document title.",
                insert_text="= ",
            ),
            CompletionItem(
                text="== Heading",
                kind=CompletionKind.SYNTAX,
                detail="Level 2 heading (section)",
                insert_text="== ",
            ),
            # ... more headings

            # Lists
            CompletionItem(
                text="* Unordered list",
                kind=CompletionKind.SYNTAX,
                detail="Unordered list item",
                insert_text="* ",
            ),
            CompletionItem(
                text=". Ordered list",
                kind=CompletionKind.SYNTAX,
                detail="Ordered list item",
                insert_text=". ",
            ),

            # Blocks
            CompletionItem(
                text="[source,python]",
                kind=CompletionKind.SYNTAX,
                detail="Source code block",
                insert_text="[source,python]\n----\n$1\n----",
            ),
            CompletionItem(
                text="[example]",
                kind=CompletionKind.SYNTAX,
                detail="Example block",
                insert_text="[example]\n====\n$1\n====",
            ),

            # Inline
            CompletionItem(
                text="link:URL[text]",
                kind=CompletionKind.SYNTAX,
                detail="External link",
                insert_text="link:${1:URL}[${2:text}]",
            ),
            CompletionItem(
                text="image::path[]",
                kind=CompletionKind.SYNTAX,
                detail="Block image",
                insert_text="image::${1:path}[${2:alt text}]",
            ),
        ]

    def _get_heading_completions(self, context: CompletionContext) -> List[CompletionItem]:
        """Get heading-specific completions"""
        level = len(context.line) - len(context.line.lstrip("="))
        return [
            item for item in self.completions
            if item.text.startswith("=" * level)
        ]

    def _get_block_completions(self, context: CompletionContext) -> List[CompletionItem]:
        """Get block-specific completions"""
        return [
            item for item in self.completions
            if item.text.startswith("[")
        ]
```

### AutoCompleteWidget

```python
from PySide6.QtWidgets import QListWidget, QListWidgetItem
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QKeyEvent

class AutoCompleteWidget(QListWidget):
    """Popup widget for showing completions"""

    item_selected = Signal(CompletionItem)  # Emitted when user selects item
    cancelled = Signal()                     # Emitted when user presses Escape

    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.setWindowFlags(Qt.Popup)
        self.setFocusPolicy(Qt.NoFocus)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setMaximumHeight(300)
        self.setMinimumWidth(400)

        # Store completion items
        self.items: List[CompletionItem] = []

        # Connect signals
        self.itemClicked.connect(self._on_item_clicked)

    def show_completions(self, items: List[CompletionItem]) -> None:
        """Show completion items"""
        self.items = items
        self.clear()

        for item in items:
            list_item = QListWidgetItem(item.text)
            list_item.setData(Qt.UserRole, item)  # Store CompletionItem
            list_item.setToolTip(item.detail)
            self.addItem(list_item)

        if items:
            self.setCurrentRow(0)
            self.show()

    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle keyboard navigation"""
        key = event.key()

        if key == Qt.Key_Return or key == Qt.Key_Enter:
            # Select current item
            current = self.currentItem()
            if current:
                item = current.data(Qt.UserRole)
                self.item_selected.emit(item)
                self.hide()
        elif key == Qt.Key_Escape:
            # Cancel
            self.cancelled.emit()
            self.hide()
        elif key == Qt.Key_Up or key == Qt.Key_Down:
            # Navigate list
            super().keyPressEvent(event)
        else:
            # Pass to editor
            self.parent().keyPressEvent(event)

    def _on_item_clicked(self, list_item: QListWidgetItem) -> None:
        """Handle item click"""
        item = list_item.data(Qt.UserRole)
        self.item_selected.emit(item)
        self.hide()
```

### AutoCompleteManager

```python
from PySide6.QtCore import QObject, QTimer
from PySide6.QtWidgets import QPlainTextEdit

class AutoCompleteManager(QObject):
    """Manages auto-complete for editor"""

    def __init__(self, editor: QPlainTextEdit, engine: AutoCompleteEngine) -> None:
        super().__init__()
        self.editor = editor
        self.engine = engine
        self.widget = AutoCompleteWidget(editor)

        # Debounce timer
        self.timer = QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self._show_completions)

        # Settings
        self.enabled = True
        self.auto_delay = 300  # ms

        # Connect editor signals
        self.editor.textChanged.connect(self._on_text_changed)

        # Connect widget signals
        self.widget.item_selected.connect(self._insert_completion)
        self.widget.cancelled.connect(self._on_cancelled)

    def _on_text_changed(self) -> None:
        """Handle text change in editor"""
        if not self.enabled:
            return

        # Restart debounce timer
        self.timer.stop()
        self.timer.start(self.auto_delay)

    def _show_completions(self) -> None:
        """Show completion popup"""
        # Get context
        context = self._get_context()

        # Get completions
        items = self.engine.get_completions(context)

        if items:
            # Position widget
            cursor_rect = self.editor.cursorRect()
            pos = self.editor.mapToGlobal(cursor_rect.bottomLeft())
            self.widget.move(pos)

            # Show widget
            self.widget.show_completions(items)

    def trigger_manual(self) -> None:
        """Manually trigger completion (Ctrl+Space)"""
        context = self._get_context()
        context.manual = True

        items = self.engine.get_completions(context)

        if items:
            cursor_rect = self.editor.cursorRect()
            pos = self.editor.mapToGlobal(cursor_rect.bottomLeft())
            self.widget.move(pos)
            self.widget.show_completions(items)

    def _get_context(self) -> CompletionContext:
        """Extract completion context from editor"""
        cursor = self.editor.textCursor()
        line_number = cursor.blockNumber()
        column = cursor.columnNumber()

        block = cursor.block()
        line = block.text()
        prefix = line[:column]

        return CompletionContext(
            line=line,
            line_number=line_number,
            column=column,
            prefix=prefix,
            trigger_char=prefix[-1] if prefix else None,
        )

    def _insert_completion(self, item: CompletionItem) -> None:
        """Insert completion text"""
        cursor = self.editor.textCursor()

        # Delete word before cursor
        context = self._get_context()
        word = context.word_before_cursor
        for _ in range(len(word)):
            cursor.deletePreviousChar()

        # Insert completion text
        cursor.insertText(item.insert_text or item.text)

        self.editor.setTextCursor(cursor)

    def _on_cancelled(self) -> None:
        """Handle cancellation"""
        self.editor.setFocus()
```

---

## Test Strategy

### Unit Tests (40 tests)

**AutoCompleteEngine (20 tests):**
- `test_exact_match_scores_100()`
- `test_prefix_match_scores_80_plus()`
- `test_fuzzy_match_scores_below_60()`
- `test_no_match_scores_0()`
- `test_ranking_prefix_before_fuzzy()`
- `test_ranking_alphabetical_tiebreaker()`
- `test_max_items_limit()`
- `test_cache_hit()`
- `test_cache_miss()`
- `test_cache_eviction()`
- `test_multiple_providers()`
- `test_empty_query()`
- `test_no_completions()`
- `test_special_characters_in_query()`
- `test_unicode_handling()`
- `test_performance_1000_items()` - <50ms
- `test_performance_10000_items()` - <200ms
- `test_thread_safety()`
- `test_provider_exception_handling()`
- `test_cache_key_generation()`

**SyntaxProvider (10 tests):**
- `test_heading_completions()`
- `test_list_completions()`
- `test_block_completions()`
- `test_inline_completions()`
- `test_filter_by_prefix()`
- `test_heading_level_detection()`
- `test_block_context_detection()`
- `test_empty_context()`
- `test_completion_count()` - verify 100+ items
- `test_insert_text_format()`

**Other Providers (10 tests):**
- `test_attribute_provider_builtin()`
- `test_attribute_provider_custom()`
- `test_attribute_provider_references()`
- `test_xref_provider_anchors()`
- `test_xref_provider_fuzzy_search()`
- `test_include_provider_files()`
- `test_include_provider_recent()`
- `test_snippet_provider_builtin()`
- `test_snippet_provider_custom()`
- `test_snippet_provider_placeholders()`

### Integration Tests (10 tests)

**Qt Widget Tests:**
- `test_widget_show_hide()`
- `test_widget_keyboard_navigation()`
- `test_widget_item_selection()`
- `test_widget_escape_cancels()`
- `test_widget_enter_selects()`

**Manager Tests:**
- `test_manager_auto_trigger()`
- `test_manager_manual_trigger()`
- `test_manager_insert_completion()`
- `test_manager_debounce()`
- `test_manager_enabled_disabled()`

### Performance Tests (5 tests)

- `test_completion_response_time()` - <50ms for 1000 items
- `test_fuzzy_matching_performance()` - <10ms for 100 items
- `test_cache_effectiveness()` - 90%+ hit rate
- `test_memory_usage()` - <10MB for 10000 items
- `test_startup_impact()` - <50ms added to startup

**Total: 65 tests**

---

## Performance Optimization

### Strategies

1. **Caching**
   - LRU cache for completion results (1000 items)
   - Cache key: line_number + column + word_before_cursor
   - 90%+ hit rate expected

2. **Lazy Loading**
   - Load snippet library on first use
   - Load include paths on demand
   - Defer expensive provider initialization

3. **Incremental Updates**
   - Only recompute if context changed significantly
   - Skip providers that can't match current context

4. **Fuzzy Matching Optimization**
   - Use rapidfuzz (Rust-based, 10x faster than fuzzywuzzy)
   - Limit fuzzy search to top 200 candidates
   - Early exit for low scores

5. **Threading**
   - Run completion engine in background thread
   - Non-blocking UI updates via signals

### Benchmarks

**Target Performance:**
- Completion response: <50ms (P95)
- Fuzzy matching: <10ms for 100 items
- Snippet expansion: <25ms
- Startup impact: <50ms

**Profiling:**
- Use `scripts/benchmark_performance.py`
- Add `@profile` decorator to hot paths
- Document performance in commit messages

---

## User Experience

### Auto-Trigger Behavior

**When to show completions:**
- After typing 3+ characters
- After trigger character (`:`, `[`, `<<`)
- After 300ms of no typing
- Minimum 1 completion item

**When NOT to show:**
- Inside comments
- Inside code blocks
- Less than 3 characters typed
- No matching completions

### Manual Trigger (Ctrl+Space)

**Always show completions:**
- Even with 0 characters typed
- Even inside comments/code blocks
- Show all available completions

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `Ctrl+Space` | Trigger completion manually |
| `Up/Down` | Navigate list |
| `Enter` | Insert selected item |
| `Escape` | Cancel and hide popup |
| `Tab` | Next snippet tab stop (Phase 4) |
| `Shift+Tab` | Previous snippet tab stop (Phase 4) |

### Visual Design

**Popup Widget:**
- Max height: 300px (scrollable)
- Min width: 400px
- Font: Match editor font
- Highlight: Selected item in blue
- Icon: CompletionKind icon (optional)

**Documentation Preview (Phase 4):**
- Right pane with markdown rendering
- Show on item hover/selection
- Collapsible

---

## Settings Integration

### Settings Schema

```python
# In core/settings.py

autocomplete_enabled: bool = True
autocomplete_auto_delay: int = 300  # ms
autocomplete_max_items: int = 100
autocomplete_trigger_chars: List[str] = [":", "[", "<"]
autocomplete_snippet_dir: str = ""  # Custom snippet directory
autocomplete_show_documentation: bool = False  # Phase 4
```

### Settings UI

**In Preferences Dialog (Tools â†’ Preferences):**

**Auto-Complete Tab:**
- [ ] Enable auto-complete
- Auto-show delay: [300] ms
- Max items shown: [100]
- Trigger characters: [:, [, <]
- Custom snippet directory: [Browse...]
- [ ] Show documentation preview (Phase 4)

---

## Deferred Features (v2.1+)

**Not in v2.0.0:**
- Documentation preview pane (basic tooltip only)
- Icon for CompletionKind (text only)
- Context-aware completions from document (only built-in)
- AI-powered suggestions
- Multi-cursor completion
- Completion history/frequency tracking
- Export/import snippet library

---

## Next Steps

1. âœ… Create this detailed plan
2. ðŸ“‹ Set up project structure (`core/`, `ui/`, `tests/`)
3. ðŸ“‹ Implement Phase 1: Core Engine (8-10h)
4. ðŸ“‹ Implement Phase 2: Providers (6-8h)
5. ðŸ“‹ Implement Phase 3: Qt Integration (6-8h)
6. ðŸ“‹ Implement Phase 4: Snippets (4-6h)
7. ðŸ“‹ Write documentation
8. ðŸ“‹ Integration testing with main app

---

**Last Updated:** November 8, 2025
**Owner:** AsciiDoc Artisan Development Team
**Status:** Ready for Implementation
